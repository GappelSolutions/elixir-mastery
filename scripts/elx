#!/usr/bin/env bash
# Elixir Learning CLI - Track progress through docs AND exercises

# Don't exit on error - we handle errors gracefully
set +e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
STATE_FILE="$PROJECT_DIR/.elx-state"
PROGRESS_FILE="$PROJECT_DIR/PROGRESS.md"

SECTIONS=(
  "01-elixir-core"
  "02-otp"
  "03-phoenix"
  "04-ecto"
  "05-liveview"
  "06-channels"
  "07-testing"
  "08-deployment"
  "09-advanced"
  "10-metaprogramming"
)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Load state
load_state() {
  if [[ -f "$STATE_FILE" ]]; then
    source "$STATE_FILE"
  else
    CURRENT_SECTION="01-elixir-core"
    CURRENT_ITEM="01-pattern-matching"
    CURRENT_TYPE="doc"  # doc or exercise
    save_state
  fi

  # Initialize progress file if needed
  [[ ! -f "$PROGRESS_FILE" ]] && init_progress_file
}

save_state() {
  cat > "$STATE_FILE" << EOF
CURRENT_SECTION="$CURRENT_SECTION"
CURRENT_ITEM="$CURRENT_ITEM"
CURRENT_TYPE="$CURRENT_TYPE"
EOF
}

init_progress_file() {
  cat > "$PROGRESS_FILE" << 'EOF'
# Elixir Mastery Progress

Track your learning journey. Items marked with [x] are complete.

EOF

  for section in "${SECTIONS[@]}"; do
    echo "## $section" >> "$PROGRESS_FILE"
    echo "" >> "$PROGRESS_FILE"

    local -A docs=()
    local -A exercises=()
    local all_names=()

    # Collect docs
    local docs_dir="$PROJECT_DIR/$section"
    if [[ -d "$docs_dir" ]]; then
      for doc in $(ls "$docs_dir"/*.md 2>/dev/null | sort); do
        local name=$(basename "$doc" .md)
        docs["$name"]=1
        all_names+=("$name")
      done
    fi

    # Collect exercises
    local ex_dir="$PROJECT_DIR/exercises/$section"
    if [[ -d "$ex_dir" ]]; then
      for ex in $(ls "$ex_dir"/*.ex 2>/dev/null | sort); do
        local name=$(basename "$ex" .ex)
        exercises["$name"]=1
        if [[ -z "${docs[$name]}" ]]; then
          all_names+=("$name")
        fi
      done
    fi

    # Sort and interleave
    local sorted_names=($(printf '%s\n' "${all_names[@]}" | sort -u))
    for name in "${sorted_names[@]}"; do
      [[ -n "${docs[$name]}" ]] && echo "- [ ] ðŸ“– $name" >> "$PROGRESS_FILE"
      [[ -n "${exercises[$name]}" ]] && echo "- [ ] ðŸ’» $name (exercise)" >> "$PROGRESS_FILE"
    done

    echo "" >> "$PROGRESS_FILE"
  done
}

# Get all items (docs + exercises) for a section - interleaved
get_items() {
  local section=$1
  local items=()
  local -A docs=()
  local -A exercises=()
  local all_names=()

  # Collect docs
  local docs_dir="$PROJECT_DIR/$section"
  if [[ -d "$docs_dir" ]]; then
    for doc in $(ls "$docs_dir"/*.md 2>/dev/null | sort); do
      local name=$(basename "$doc" .md)
      docs["$name"]=1
      all_names+=("$name")
    done
  fi

  # Collect exercises
  local ex_dir="$PROJECT_DIR/exercises/$section"
  if [[ -d "$ex_dir" ]]; then
    for ex in $(ls "$ex_dir"/*.ex 2>/dev/null | sort); do
      local name=$(basename "$ex" .ex)
      exercises["$name"]=1
      # Only add if not already in list from docs
      if [[ -z "${docs[$name]}" ]]; then
        all_names+=("$name")
      fi
    done
  fi

  # Sort and interleave: for each name, add doc then exercise
  local sorted_names=($(printf '%s\n' "${all_names[@]}" | sort -u))
  for name in "${sorted_names[@]}"; do
    [[ -n "${docs[$name]}" ]] && items+=("doc:$name")
    [[ -n "${exercises[$name]}" ]] && items+=("exercise:$name")
  done

  echo "${items[@]}"
}

# Check if item is complete
is_complete() {
  local section=$1
  local type=$2
  local name=$3

  local icon="ðŸ“–"
  [[ "$type" == "exercise" ]] && icon="ðŸ’»"

  grep -q "\[x\] $icon $name" "$PROGRESS_FILE" 2>/dev/null
}

# Mark item complete
mark_complete() {
  local section=$1
  local type=$2
  local name=$3

  local icon="ðŸ“–"
  local suffix=""
  [[ "$type" == "exercise" ]] && icon="ðŸ’»" && suffix=" (exercise)"

  # Use sed to mark complete
  if [[ "$(uname)" == "Darwin" ]]; then
    sed -i '' "s/\- \[ \] $icon $name$suffix/- [x] $icon $name$suffix/" "$PROGRESS_FILE"
  else
    sed -i "s/\- \[ \] $icon $name$suffix/- [x] $icon $name$suffix/" "$PROGRESS_FILE"
  fi
}

# Count progress
count_progress() {
  local section=$1
  local total=0
  local done=0

  if [[ ! -f "$PROGRESS_FILE" ]]; then
    echo "0/0"
    return
  fi

  if [[ -z "$section" ]]; then
    total=$(grep -c "^\- \[" "$PROGRESS_FILE" 2>/dev/null) || total=0
    done=$(grep -c "^\- \[x\]" "$PROGRESS_FILE" 2>/dev/null) || done=0
  else
    # Count for specific section
    local section_content
    section_content=$(sed -n "/^## $section\$/,/^## /p" "$PROGRESS_FILE" 2>/dev/null)
    total=$(echo "$section_content" | grep -c "^\- \[" 2>/dev/null) || total=0
    done=$(echo "$section_content" | grep -c "^\- \[x\]" 2>/dev/null) || done=0
  fi

  printf "%d/%d" "$done" "$total"
}

# Display status
show_status() {
  clear
  echo -e "${BOLD}${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${BOLD}${CYAN}â•‘       ELIXIR MASTERY - Learning Tracker       â•‘${NC}"
  echo -e "${BOLD}${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""

  local progress=$(count_progress)
  local section_progress=$(count_progress "$CURRENT_SECTION")
  echo -e "${BOLD}Overall:${NC} ${GREEN}$progress${NC} complete"
  echo ""

  local type_icon="ðŸ“–"
  local type_label="Doc"
  [[ "$CURRENT_TYPE" == "exercise" ]] && type_icon="ðŸ’»" && type_label="Exercise"

  echo -e "${BOLD}Section:${NC}  ${YELLOW}$CURRENT_SECTION${NC} ($section_progress)"
  echo -e "${BOLD}Current:${NC}  $type_icon ${YELLOW}$CURRENT_ITEM${NC} ${DIM}($type_label)${NC}"

  # Show completion status
  if is_complete "$CURRENT_SECTION" "$CURRENT_TYPE" "$CURRENT_ITEM"; then
    echo -e "          ${GREEN}âœ“ Completed${NC}"
  else
    echo -e "          ${DIM}â—‹ In progress${NC}"
  fi

  # For exercises, show TODO count
  if [[ "$CURRENT_TYPE" == "exercise" ]]; then
    local ex_file="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_ITEM.ex"
    if [[ -f "$ex_file" ]]; then
      local todos=$(grep -c ":todo" "$ex_file" 2>/dev/null || echo "0")
      if [[ "$todos" -gt 0 ]]; then
        echo -e "          ${YELLOW}$todos exercises remaining${NC}"
      fi
    fi
  fi

  echo ""
  echo -e "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

# Menu
show_menu() {
  echo ""
  echo -e "${BOLD}Navigation${NC}          ${BOLD}Actions${NC}"
  echo -e "  ${CYAN}n${NC} Next item        ${CYAN}o${NC} Open current"
  echo -e "  ${CYAN}p${NC} Previous         ${CYAN}t${NC} Run tests ${DIM}(exercise)${NC}"
  echo -e "  ${CYAN}j${NC} Jump section     ${CYAN}f${NC} Get feedback"
  echo -e "  ${CYAN}l${NC} List all         ${CYAN}s${NC} View solution"
  echo ""
  echo -e "${BOLD}Progress${NC}"
  echo -e "  ${CYAN}x${NC} Mark complete    ${CYAN}c${NC} Commit progress"
  echo -e "  ${CYAN}q${NC} Quit"
  echo ""
  echo -ne "${BOLD}> ${NC}"
}

# Open current item
open_current() {
  if [[ "$CURRENT_TYPE" == "doc" ]]; then
    local doc_file="$PROJECT_DIR/$CURRENT_SECTION/$CURRENT_ITEM.md"
    [[ -f "$doc_file" ]] && nvim "$doc_file"
  else
    local ex_file="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_ITEM.ex"
    [[ -f "$ex_file" ]] && nvim "$ex_file"
  fi
}

# Run tests
run_tests() {
  if [[ "$CURRENT_TYPE" != "exercise" ]]; then
    echo -e "${YELLOW}No tests for docs. Press 'n' to go to exercise.${NC}"
    read -n1 -s
    return
  fi

  local ex_file="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_ITEM.ex"
  if [[ -f "$ex_file" ]]; then
    echo -e "${CYAN}Running tests...${NC}"
    echo ""
    elixir "$ex_file"
  else
    echo -e "${RED}No exercise file found${NC}"
  fi
  echo ""
  read -n1 -s -p "Press any key..."
}

# Get feedback
get_feedback() {
  local file
  if [[ "$CURRENT_TYPE" == "doc" ]]; then
    file="$PROJECT_DIR/$CURRENT_SECTION/$CURRENT_ITEM.md"
  else
    file="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_ITEM.ex"
  fi

  if [[ -f "$file" ]]; then
    echo -e "${CYAN}Run in agent tab:${NC}"
    echo -e "${YELLOW}/elixir-review $file${NC}"
    echo "$file" | pbcopy 2>/dev/null || true
    echo -e "${GREEN}Path copied to clipboard${NC}"
  fi
  read -n1 -s -p "Press any key..."
}

# View solution
view_solution() {
  local solution_file="$PROJECT_DIR/exercises/solutions/$CURRENT_ITEM.ex"
  if [[ -f "$solution_file" ]]; then
    echo -e "${YELLOW}View solution? (y/N)${NC}"
    read -n1 confirm
    echo ""
    [[ "$confirm" =~ ^[Yy]$ ]] && nvim -R "$solution_file"
  else
    echo -e "${YELLOW}No solution available${NC}"
    sleep 1
  fi
}

# Mark current complete
mark_current_complete() {
  mark_complete "$CURRENT_SECTION" "$CURRENT_TYPE" "$CURRENT_ITEM"
  echo -e "${GREEN}âœ“ Marked complete!${NC}"
  sleep 0.5
}

# Navigate
navigate() {
  local direction=$1
  local items_str
  items_str=$(get_items "$CURRENT_SECTION")
  local -a items=($items_str)
  local current_key="$CURRENT_TYPE:$CURRENT_ITEM"
  local current_idx=0
  local num_items=${#items[@]}

  if [[ $num_items -eq 0 ]]; then
    return
  fi

  for i in "${!items[@]}"; do
    if [[ "${items[$i]}" == "$current_key" ]]; then
      current_idx=$i
      break
    fi
  done

  local new_idx
  if [[ "$direction" == "next" ]]; then
    new_idx=$((current_idx + 1))
  else
    new_idx=$((current_idx - 1))
  fi

  if [[ $new_idx -ge 0 && $new_idx -lt $num_items ]]; then
    local new_item="${items[$new_idx]}"
    CURRENT_TYPE="${new_item%%:*}"
    CURRENT_ITEM="${new_item#*:}"
    save_state
  elif [[ "$direction" == "next" && $new_idx -ge $num_items ]]; then
    next_section
  elif [[ "$direction" == "prev" && $new_idx -lt 0 ]]; then
    prev_section
  fi
}

next_section() {
  local current_idx=0
  for i in "${!SECTIONS[@]}"; do
    if [[ "${SECTIONS[$i]}" == "$CURRENT_SECTION" ]]; then
      current_idx=$i
      break
    fi
  done

  local next_idx=$((current_idx + 1))
  if [[ $next_idx -lt ${#SECTIONS[@]} ]]; then
    CURRENT_SECTION="${SECTIONS[$next_idx]}"
    local items_str
    items_str=$(get_items "$CURRENT_SECTION")
    local -a items=($items_str)
    if [[ ${#items[@]} -gt 0 ]]; then
      local first="${items[0]}"
      CURRENT_TYPE="${first%%:*}"
      CURRENT_ITEM="${first#*:}"
    fi
    save_state
  fi
}

prev_section() {
  local current_idx=0
  for i in "${!SECTIONS[@]}"; do
    if [[ "${SECTIONS[$i]}" == "$CURRENT_SECTION" ]]; then
      current_idx=$i
      break
    fi
  done

  local prev_idx=$((current_idx - 1))
  if [[ $prev_idx -ge 0 ]]; then
    CURRENT_SECTION="${SECTIONS[$prev_idx]}"
    local items_str
    items_str=$(get_items "$CURRENT_SECTION")
    local -a items=($items_str)
    local num_items=${#items[@]}
    if [[ $num_items -gt 0 ]]; then
      # Go to last item in previous section
      local last_idx=$((num_items - 1))
      local last="${items[$last_idx]}"
      CURRENT_TYPE="${last%%:*}"
      CURRENT_ITEM="${last#*:}"
    fi
    save_state
  fi
}

# Jump to section
jump_section() {
  echo ""
  echo -e "${BOLD}Sections:${NC}"
  for i in "${!SECTIONS[@]}"; do
    local mark=" "
    [[ "${SECTIONS[$i]}" == "$CURRENT_SECTION" ]] && mark=">"
    local prog
    prog=$(count_progress "${SECTIONS[$i]}")
    echo -e "  ${CYAN}$((i+1))${NC} $mark ${SECTIONS[$i]} ${DIM}($prog)${NC}"
  done
  echo ""
  read -p "Select (1-${#SECTIONS[@]}): " choice

  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#SECTIONS[@]} ]]; then
    CURRENT_SECTION="${SECTIONS[$((choice-1))]}"

    local items_str
    items_str=$(get_items "$CURRENT_SECTION")
    local -a items=($items_str)
    local num_items=${#items[@]}

    echo ""
    echo -e "${BOLD}Items:${NC}"
    for i in "${!items[@]}"; do
      local item="${items[$i]}"
      local type="${item%%:*}"
      local name="${item#*:}"
      local icon="ðŸ“–"
      [[ "$type" == "exercise" ]] && icon="ðŸ’»"
      local status="â—‹"
      is_complete "$CURRENT_SECTION" "$type" "$name" && status="${GREEN}âœ“${NC}"
      echo -e "  ${CYAN}$((i+1))${NC} $status $icon $name"
    done
    echo ""
    read -p "Select (1-$num_items): " item_choice

    if [[ "$item_choice" =~ ^[0-9]+$ ]] && [[ $item_choice -ge 1 ]] && [[ $item_choice -le $num_items ]]; then
      local selected="${items[$((item_choice-1))]}"
      CURRENT_TYPE="${selected%%:*}"
      CURRENT_ITEM="${selected#*:}"
    fi
    save_state
  fi
}

# List all
list_all() {
  echo ""
  for section in "${SECTIONS[@]}"; do
    local prog
    prog=$(count_progress "$section")
    local mark=" "
    [[ "$section" == "$CURRENT_SECTION" ]] && mark="${CYAN}>${NC}"
    echo -e "$mark ${BOLD}$section${NC} ${DIM}($prog)${NC}"

    local items_str
    items_str=$(get_items "$section")
    local -a items=($items_str)
    for item in "${items[@]}"; do
      local type="${item%%:*}"
      local name="${item#*:}"
      local icon="ðŸ“–"
      [[ "$type" == "exercise" ]] && icon="ðŸ’»"
      local status="â—‹"
      is_complete "$section" "$type" "$name" && status="${GREEN}âœ“${NC}"
      local current=""
      [[ "$section" == "$CURRENT_SECTION" && "$type" == "$CURRENT_TYPE" && "$name" == "$CURRENT_ITEM" ]] && current=" ${YELLOW}â—€${NC}"
      echo -e "    $status $icon $name$current"
    done
  done
  echo ""
  read -n1 -s -p "Press any key..."
}

# Commit progress
commit_progress() {
  cd "$PROJECT_DIR"

  if git diff --quiet && git diff --cached --quiet; then
    echo -e "${YELLOW}No changes to commit${NC}"
    read -n1 -s
    return
  fi

  git add -A
  local msg="progress: $CURRENT_SECTION/$CURRENT_ITEM"

  # Check if completing a section
  local section_prog=$(count_progress "$CURRENT_SECTION")
  IFS='/' read -r done total <<< "$section_prog"
  [[ "$done" == "$total" ]] && msg="complete: $CURRENT_SECTION"

  git commit -m "$msg

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
  echo -e "${GREEN}âœ“ Committed: $msg${NC}"
  read -n1 -s -p "Press any key..."
}

# Main loop
main() {
  load_state

  while true; do
    show_status
    show_menu
    read -n1 cmd
    echo ""

    case $cmd in
      o) open_current ;;
      t) run_tests ;;
      f) get_feedback ;;
      s) view_solution ;;
      x) mark_current_complete ;;
      c) commit_progress ;;
      n) navigate next ;;
      p) navigate prev ;;
      j) jump_section ;;
      l) list_all ;;
      q) echo "Happy learning!"; exit 0 ;;
      *) ;;
    esac
  done
}

main
