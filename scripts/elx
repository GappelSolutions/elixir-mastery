#!/usr/bin/env bash
# Elixir Learning CLI - Track progress through topics

set +e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
STATE_FILE="$PROJECT_DIR/.elx-state"
PROGRESS_FILE="$PROJECT_DIR/PROGRESS.md"

SECTIONS=(
  "01-elixir-core"
  "02-otp"
  "03-phoenix"
  "04-ecto"
  "05-liveview"
  "06-channels"
  "07-testing"
  "08-deployment"
  "09-advanced"
  "10-metaprogramming"
)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

load_state() {
  if [[ -f "$STATE_FILE" ]]; then
    source "$STATE_FILE"
  else
    CURRENT_SECTION="01-elixir-core"
    CURRENT_TOPIC="01-pattern-matching"
    CURRENT_EXERCISE=1
    save_state
  fi
  [[ -z "$CURRENT_EXERCISE" ]] && CURRENT_EXERCISE=1
  [[ ! -f "$PROGRESS_FILE" ]] && init_progress_file
}

save_state() {
  echo "CURRENT_SECTION=\"$CURRENT_SECTION\"" > "$STATE_FILE"
  echo "CURRENT_TOPIC=\"$CURRENT_TOPIC\"" >> "$STATE_FILE"
  echo "CURRENT_EXERCISE=$CURRENT_EXERCISE" >> "$STATE_FILE"
}

# Get all topics for a section
get_topics() {
  local section=$1
  local docs_dir="$PROJECT_DIR/$section"
  local ex_dir="$PROJECT_DIR/exercises/$section"
  local all_names=""

  if [[ -d "$docs_dir" ]]; then
    for f in "$docs_dir"/*.md; do
      [[ -e "$f" ]] || continue
      all_names="$all_names $(basename "$f" .md)"
    done
  fi

  if [[ -d "$ex_dir" ]]; then
    for f in "$ex_dir"/*.ex; do
      [[ -e "$f" ]] || continue
      all_names="$all_names $(basename "$f" .ex)"
    done
  fi

  echo "$all_names" | tr ' ' '\n' | grep -v '^$' | sort -u | tr '\n' ' '
}

init_progress_file() {
  cat > "$PROGRESS_FILE" << 'EOF'
# Elixir Mastery Progress

Track your learning journey. Items marked with [x] are complete.

EOF

  for section in "${SECTIONS[@]}"; do
    echo "## $section" >> "$PROGRESS_FILE"
    echo "" >> "$PROGRESS_FILE"

    local topics=$(get_topics "$section")
    for topic in $topics; do
      echo "- [ ] $topic" >> "$PROGRESS_FILE"
    done
    echo "" >> "$PROGRESS_FILE"
  done
}

is_complete() {
  local topic=$1
  grep -q "\[x\] $topic$" "$PROGRESS_FILE" 2>/dev/null
}

toggle_complete() {
  local topic=$1
  if is_complete "$topic"; then
    # Mark incomplete
    if [[ "$(uname)" == "Darwin" ]]; then
      sed -i '' "s/- \[x\] $topic$/- [ ] $topic/" "$PROGRESS_FILE"
    else
      sed -i "s/- \[x\] $topic$/- [ ] $topic/" "$PROGRESS_FILE"
    fi
  else
    # Mark complete
    if [[ "$(uname)" == "Darwin" ]]; then
      sed -i '' "s/- \[ \] $topic$/- [x] $topic/" "$PROGRESS_FILE"
    else
      sed -i "s/- \[ \] $topic$/- [x] $topic/" "$PROGRESS_FILE"
    fi
  fi
}

count_progress() {
  local section=$1
  local total=0 done=0

  if [[ ! -f "$PROGRESS_FILE" ]]; then
    printf "0/0"
    return
  fi

  if [[ -z "$section" ]]; then
    total=$(grep -c "^\- \[" "$PROGRESS_FILE" 2>/dev/null) || total=0
    done=$(grep -c "^\- \[x\]" "$PROGRESS_FILE" 2>/dev/null) || done=0
  else
    local content
    content=$(sed -n "/^## $section\$/,/^## /p" "$PROGRESS_FILE" 2>/dev/null)
    total=$(echo "$content" | grep -c "^\- \[" 2>/dev/null) || total=0
    done=$(echo "$content" | grep -c "^\- \[x\]" 2>/dev/null) || done=0
  fi

  printf "%d/%d" "$done" "$total"
}

has_doc() {
  [[ -f "$PROJECT_DIR/$CURRENT_SECTION/$1.md" ]]
}

has_exercise() {
  [[ -f "$PROJECT_DIR/exercises/$CURRENT_SECTION/$1.ex" ]]
}

count_exercises() {
  local ex=$1
  grep -c "defmodule Exercise[0-9]" "$ex" 2>/dev/null || echo 0
}

sync_exercise_to_file() {
  # Sync CURRENT_EXERCISE to actual first incomplete exercise in file
  local ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
  [[ ! -f "$ex" ]] && return
  CURRENT_EXERCISE=$(get_current_exercise "$ex")
  save_state
}

show_status() {
  clear
  echo -e "${BOLD}${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${BOLD}${CYAN}â•‘       ELIXIR MASTERY - Learning Tracker       â•‘${NC}"
  echo -e "${BOLD}${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""

  local progress=$(count_progress)
  local section_progress=$(count_progress "$CURRENT_SECTION")
  echo -e "${BOLD}Overall:${NC} ${GREEN}$progress${NC} complete"
  echo ""
  echo -e "${BOLD}Section:${NC} ${YELLOW}$CURRENT_SECTION${NC} ($section_progress)"
  echo -e "${BOLD}Topic:${NC}   ${YELLOW}$CURRENT_TOPIC${NC}"

  # Show what's available
  local avail=""
  has_doc "$CURRENT_TOPIC" && avail="ðŸ“– doc"
  has_exercise "$CURRENT_TOPIC" && avail="$avail ðŸ’» exercise"
  echo -e "         ${DIM}$avail${NC}"

  local ex_file="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"

  # Show current exercise step
  if [[ -f "$ex_file" ]]; then
    local total=$(count_exercises "$ex_file")
    local describe=$(get_exercise_describe "$ex_file" "$CURRENT_EXERCISE")
    if [[ $total -gt 0 ]]; then
      echo ""
      echo -e "${BOLD}Exercise:${NC} ${GREEN}$CURRENT_EXERCISE${NC}/${total} - ${CYAN}${describe#Exercise* - }${NC}"
    fi
  fi

  # Completion status
  if is_complete "$CURRENT_TOPIC"; then
    echo -e "         ${GREEN}âœ“ Topic completed${NC}"
  else
    if [[ -f "$ex_file" ]]; then
      local todos=$(grep -c ":todo" "$ex_file" 2>/dev/null) || todos=0
      if [[ $todos -gt 0 ]]; then
        echo -e "         ${DIM}â—‹ $todos exercises remaining${NC}"
      else
        echo -e "         ${GREEN}âœ“ All exercises done!${NC}"
      fi
    fi
  fi

  echo ""
  echo -e "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

show_menu() {
  echo ""
  echo -e "${BOLD}Exercises${NC}           ${BOLD}Actions${NC}"
  echo -e "  ${CYAN}n${NC} Next step       ${CYAN}d${NC} Open doc"
  echo -e "  ${CYAN}p${NC} Prev step       ${CYAN}e${NC} Open exercise"
  echo -e "                    ${CYAN}t${NC} Run tests"
  echo -e "${BOLD}Topics${NC}              ${CYAN}a${NC} All tests"
  echo -e "  ${CYAN}w${NC} Next topic      ${CYAN}f${NC} Get feedback"
  echo -e "  ${CYAN}b${NC} Prev topic      ${CYAN}s${NC} View solution"
  echo -e "  ${CYAN}j${NC} Jump"
  echo -e "  ${CYAN}l${NC} List all      ${BOLD}Progress${NC}"
  echo -e "                    ${CYAN}x${NC} Mark complete"
  echo -e "  ${CYAN}q${NC} Quit            ${CYAN}c${NC} Commit"
  echo ""
  echo -ne "${BOLD}> ${NC}"
}

open_doc() {
  local doc="$PROJECT_DIR/$CURRENT_SECTION/$CURRENT_TOPIC.md"
  [[ -f "$doc" ]] && nvim "$doc" || echo -e "${YELLOW}No doc for this topic${NC}"
}

open_exercise() {
  local ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
  [[ -f "$ex" ]] && nvim "$ex" || echo -e "${YELLOW}No exercise for this topic${NC}"
}

get_current_exercise() {
  local ex=$1
  local current=1

  # Find first exercise module that still has :todo
  for i in 1 2 3 4 5 6 7 8 9 10; do
    local line
    line=$(grep -n "defmodule Exercise$i\b" "$ex" 2>/dev/null | head -1 | cut -d: -f1)
    if [[ -n "$line" ]]; then
      # Check next 15 lines for :todo
      if sed -n "${line},$((line+15))p" "$ex" | grep -q ":todo"; then
        current=$i
        break
      fi
      current=$((i+1))  # Move to next if this one is done
    fi
  done
  echo $current
}

get_exercise_describe() {
  local ex=$1
  local num=$2
  # Extract the describe block name for this exercise
  grep "describe \"Exercise $num" "$ex" | head -1 | sed 's/.*describe "\([^"]*\)".*/\1/'
}

run_tests() {
  local ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
  if [[ ! -f "$ex" ]]; then
    echo -e "${YELLOW}No exercise file${NC}"
    echo ""
    read -n1 -s -p "Press any key..."
    return
  fi

  local describe_name=$(get_exercise_describe "$ex" "$CURRENT_EXERCISE")

  if [[ -z "$describe_name" ]]; then
    echo -e "${YELLOW}No exercise $CURRENT_EXERCISE found${NC}"
    echo ""
    read -n1 -s -p "Press any key..."
    return
  fi

  echo -e "${CYAN}Testing: $describe_name${NC}"
  echo ""

  # Create a filtered test runner
  local runner="/tmp/elx_test_runner_$$.exs"
  cat > "$runner" << RUNNER
ExUnit.start(auto_run: true)
ExUnit.configure(exclude: [:test], include: [describe: "$describe_name"])
Code.compile_file("$ex")
# Tests run automatically via at_exit hook
RUNNER

  # Run tests with full output
  ELX_EXTERNAL_RUNNER=1 elixir "$runner" 2>&1
  rm -f "$runner"

  echo ""
  read -n1 -s -p "Press any key (r to rerun)..." key
  [[ "$key" == "r" ]] && clear && run_tests
}

run_all_tests() {
  local ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
  if [[ -f "$ex" ]]; then
    echo -e "${CYAN}Running all tests...${NC}"
    echo ""
    elixir "$ex"
  else
    echo -e "${YELLOW}No exercise file${NC}"
  fi
  echo ""
  read -n1 -s -p "Press any key (r to rerun)..." key
  [[ "$key" == "r" ]] && clear && run_all_tests
}

get_feedback() {
  local ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
  if [[ -f "$ex" ]]; then
    local prompt="/elixir-review $ex exercise:$CURRENT_EXERCISE"
    echo -e "${CYAN}Run in agent tab:${NC}"
    echo -e "${YELLOW}$prompt${NC}"
    echo "$prompt" | pbcopy 2>/dev/null || true
    echo -e "${GREEN}Prompt copied${NC}"
  else
    echo -e "${YELLOW}No exercise file${NC}"
  fi
  read -n1 -s -p "Press any key..."
}

view_solution() {
  local sol="$PROJECT_DIR/exercises/solutions/$CURRENT_TOPIC.ex"
  if [[ -f "$sol" ]]; then
    echo -e "${YELLOW}View solution? (y/N)${NC}"
    read -n1 confirm
    echo ""
    [[ "$confirm" =~ ^[Yy]$ ]] && nvim -R "$sol"
  else
    echo -e "${YELLOW}No solution available${NC}"
    sleep 1
  fi
}

navigate_exercise() {
  local direction=$1
  local ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
  [[ ! -f "$ex" ]] && return

  local total=$(count_exercises "$ex")
  [[ $total -eq 0 ]] && return

  if [[ "$direction" == "next" ]]; then
    if [[ $CURRENT_EXERCISE -lt $total ]]; then
      CURRENT_EXERCISE=$((CURRENT_EXERCISE + 1))
      save_state
    else
      # At last exercise, move to next topic
      navigate next
      CURRENT_EXERCISE=1
      save_state
    fi
  else
    if [[ $CURRENT_EXERCISE -gt 1 ]]; then
      CURRENT_EXERCISE=$((CURRENT_EXERCISE - 1))
      save_state
    else
      # At first exercise, move to previous topic
      navigate prev
      # Set to last exercise of previous topic
      local prev_ex="$PROJECT_DIR/exercises/$CURRENT_SECTION/$CURRENT_TOPIC.ex"
      if [[ -f "$prev_ex" ]]; then
        CURRENT_EXERCISE=$(count_exercises "$prev_ex")
        [[ $CURRENT_EXERCISE -lt 1 ]] && CURRENT_EXERCISE=1
      else
        CURRENT_EXERCISE=1
      fi
      save_state
    fi
  fi
}

navigate() {
  local direction=$1
  local topics=$(get_topics "$CURRENT_SECTION")
  local topics_arr=($topics)
  local num=${#topics_arr[@]}
  local idx=0

  for i in "${!topics_arr[@]}"; do
    [[ "${topics_arr[$i]}" == "$CURRENT_TOPIC" ]] && idx=$i && break
  done

  local new_idx
  [[ "$direction" == "next" ]] && new_idx=$((idx + 1)) || new_idx=$((idx - 1))

  if [[ $new_idx -ge 0 && $new_idx -lt $num ]]; then
    CURRENT_TOPIC="${topics_arr[$new_idx]}"
    save_state
  elif [[ "$direction" == "next" && $new_idx -ge $num ]]; then
    next_section
  elif [[ "$direction" == "prev" && $new_idx -lt 0 ]]; then
    prev_section
  fi
}

next_section() {
  local idx=0
  for i in "${!SECTIONS[@]}"; do
    [[ "${SECTIONS[$i]}" == "$CURRENT_SECTION" ]] && idx=$i && break
  done

  local next=$((idx + 1))
  if [[ $next -lt ${#SECTIONS[@]} ]]; then
    CURRENT_SECTION="${SECTIONS[$next]}"
    local topics=$(get_topics "$CURRENT_SECTION")
    local arr=($topics)
    [[ ${#arr[@]} -gt 0 ]] && CURRENT_TOPIC="${arr[0]}"
    save_state
  fi
}

prev_section() {
  local idx=0
  for i in "${!SECTIONS[@]}"; do
    [[ "${SECTIONS[$i]}" == "$CURRENT_SECTION" ]] && idx=$i && break
  done

  local prev=$((idx - 1))
  if [[ $prev -ge 0 ]]; then
    CURRENT_SECTION="${SECTIONS[$prev]}"
    local topics=$(get_topics "$CURRENT_SECTION")
    local arr=($topics)
    local last=$((${#arr[@]} - 1))
    [[ $last -ge 0 ]] && CURRENT_TOPIC="${arr[$last]}"
    save_state
  fi
}

jump_section() {
  echo ""
  echo -e "${BOLD}Sections:${NC} ${DIM}(ESC to cancel)${NC}"
  for i in "${!SECTIONS[@]}"; do
    local mark=" "
    [[ "${SECTIONS[$i]}" == "$CURRENT_SECTION" ]] && mark=">"
    local prog=$(count_progress "${SECTIONS[$i]}")
    echo -e "  ${CYAN}$((i+1))${NC} $mark ${SECTIONS[$i]} ${DIM}($prog)${NC}"
  done
  echo ""
  echo -ne "Section (1-${#SECTIONS[@]}): "
  read -n1 choice
  [[ "$choice" == $'\e' ]] && return
  # Handle 10 (two digits)
  if [[ "$choice" == "1" ]]; then
    read -t 1 -n1 second
    [[ "$second" =~ ^[0-9]$ ]] && choice="${choice}${second}"
  fi
  echo ""

  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#SECTIONS[@]} ]]; then
    CURRENT_SECTION="${SECTIONS[$((choice-1))]}"
    local topics=$(get_topics "$CURRENT_SECTION")
    local arr=($topics)

    echo ""
    echo -e "${BOLD}Topics:${NC} ${DIM}(ESC to cancel)${NC}"
    for i in "${!arr[@]}"; do
      local status="â—‹"
      is_complete "${arr[$i]}" && status="${GREEN}âœ“${NC}"
      echo -e "  ${CYAN}$((i+1))${NC} $status ${arr[$i]}"
    done
    echo ""
    echo -ne "Topic (1-${#arr[@]}): "
    read -n1 tchoice
    [[ "$tchoice" == $'\e' ]] && return
    # Handle two digits
    if [[ "$tchoice" == "1" ]] && [[ ${#arr[@]} -ge 10 ]]; then
      read -t 1 -n1 second
      [[ "$second" =~ ^[0-9]$ ]] && tchoice="${tchoice}${second}"
    fi
    echo ""

    if [[ "$tchoice" =~ ^[0-9]+$ ]] && [[ $tchoice -ge 1 ]] && [[ $tchoice -le ${#arr[@]} ]]; then
      CURRENT_TOPIC="${arr[$((tchoice-1))]}"
    fi
    save_state
  fi
}

list_all() {
  echo ""
  for section in "${SECTIONS[@]}"; do
    local prog=$(count_progress "$section")
    local mark=" "
    [[ "$section" == "$CURRENT_SECTION" ]] && mark="${CYAN}>${NC}"
    echo -e "$mark ${BOLD}$section${NC} ${DIM}($prog)${NC}"

    local topics=$(get_topics "$section")
    for topic in $topics; do
      local status="â—‹"
      is_complete "$topic" && status="${GREEN}âœ“${NC}"
      local cur=""
      [[ "$section" == "$CURRENT_SECTION" && "$topic" == "$CURRENT_TOPIC" ]] && cur=" ${YELLOW}â—€${NC}"
      echo -e "    $status $topic$cur"
    done
  done
  echo ""
  read -n1 -s -p "Press any key..."
}

commit_progress() {
  cd "$PROJECT_DIR"
  if git diff --quiet && git diff --cached --quiet; then
    echo -e "${YELLOW}No changes${NC}"
    read -n1 -s
    return
  fi

  git add -A
  local msg="progress: $CURRENT_SECTION/$CURRENT_TOPIC"
  local prog=$(count_progress "$CURRENT_SECTION")
  local done="${prog%/*}"
  local total="${prog#*/}"
  [[ "$done" == "$total" ]] && msg="complete: $CURRENT_SECTION"

  git commit -m "$msg

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
  echo -e "${GREEN}âœ“ $msg${NC}"
  read -n1 -s -p "Press any key..."
}

get_state_mtime() {
  stat -f %m "$STATE_FILE" 2>/dev/null || echo 0
}

main() {
  load_state
  sync_exercise_to_file  # Sync exercise state on startup
  local last_mtime=$(get_state_mtime)
  local needs_redraw=1
  while true; do
    if [[ $needs_redraw -eq 1 ]]; then
      show_status
      show_menu
      needs_redraw=0
    fi
    if ! read -t 1 -n1 cmd; then
      # Timeout - check if state file changed
      local current_mtime=$(get_state_mtime)
      if [[ "$current_mtime" != "$last_mtime" ]]; then
        load_state
        last_mtime=$current_mtime
        needs_redraw=1
      fi
      continue
    fi
    echo ""
    needs_redraw=1
    case $cmd in
      d) open_doc ;;
      e) open_exercise ;;
      t) run_tests ;;
      a) run_all_tests ;;
      f) get_feedback ;;
      s) view_solution ;;
      x) toggle_complete "$CURRENT_TOPIC"; sleep 0.3 ;;
      c) commit_progress ;;
      n) navigate_exercise next ;;
      p) navigate_exercise prev ;;
      w) navigate next; CURRENT_EXERCISE=1; save_state ;;
      b) navigate prev; CURRENT_EXERCISE=1; save_state ;;
      j) jump_section ;;
      l) list_all ;;
      q) echo "Happy learning!"; exit 0 ;;
    esac
  done
}

main
